Below is a check‑list + concrete patterns for the next round of work.
It tackles:
 • Sharing the study_key everywhere without boilerplate
 • A catalogue of “workflow” helpers you’ll probably want in the first public release
 • Project‑level disciplines that keep the code DRY, SOLID, and tidy long‑term

⸻

1 A single source‑of‑truth for study_key

1.1  Context object

# imednet/core/context.py

from dataclasses import dataclass

@dataclass
class Context:
    study_key: str | None = None
    sponsor_key: str | None = None   # add more defaults as needed

 • The ImednetSDK owns one Context instance.
 • Every endpoint receives it in __init__ and reads from it only when its own argument is None.

class StudyEndpoint:
    def __init__(self, client: Client, ctx: Context):
        self._c = client
        self._ctx = ctx

    def list(self, sponsor_key: str | None = None):
        sponsor_key = sponsor_key or self._ctx.sponsor_key
        return self._c.paginate("/studies", params={"sponsorKey": sponsor_key})

1.2  Setting / switching studies

sdk = ImednetSDK(API, SEC)
sdk.ctx.study_key = "PHARMADEMO"     # set once
subjects = sdk.records.list()        # no arg needed

sdk.ctx.study_key = "DEMO2"          # switch on the fly

Because every endpoint keeps a reference to the same Context, the change is instant and global.

Optional: add a tiny helper…

from contextlib import contextmanager

@contextmanager
def use_study(sdk: "ImednetSDK", study_key: str):
    old = sdk.ctx.study_key
    sdk.ctx.study_key = study_key
    try:
        yield sdk
    finally:
        sdk.ctx.study_key = old

⸻

2 Workflow ideas worth baking in early

Workflow module What it does First users
record_mapper (already sketched) Map Variables → Records → tidy DataFrame Data managers, statisticians
export_bundle ZIP of CSV/Parquet for every form/visit; includes data dictionary Biostats, sponsor upload
crf_progress % complete, # outstanding queries per site/form Study lead dashboards
query_log Flatten all queries + audit actions to DataFrame QA auditors
adverse_event_linker Join AE records with MedDRA code list & outcome summaries Safety team
lab_normalizer Convert lab units → SI; flag out‑of‑range Data cleaning scripts
subject_flow Enrollment → randomisation → discontinuation Gantt Ops & PMs
sdv_tracker Compare SDV status vs. SDTM exports Monitors / on‑site CRAs
snapshot_diff Two time‑points → highlight changed fields Lock / freeze QC
bulk_uploader Take a DataFrame → POST missing records/updates EDC migrations

Each lives in imednet/workflows/ and may:
 • depend on multiple endpoints
 • return either a pd.DataFrame, a local file path, or a rich Python object
 • raise typed errors from core.exceptions

⸻

3 Keeping it DRY, SOLID, and “Clean”

Principle Practical rule inside this repo Ref
Single‑Responsibility One reason to change per module: endpoints/*talk HTTP, models/* hold schema, workflows/*apply business logic. ￼
Open–Closed Extend with new workflow classes; never modify existing endpoints for new cross‑endpoint features. 
Liskov / Interface Segregation Endpoints share a thin base (BaseEndpointProtocol) so tests can stub them easily. 
Dependency‑Inversion workflows.* accept endpoint interfaces, not concrete classes → pass stubs in unit tests. 

The RealPython guide is a great refresher on applying SOLID in Python  ￼.

Code‑quality guard‑rails
 • ruff + black — pre‑commit → style & import hygiene
 • mypy → make the generics real, especially around paginated JSON → list[Record]
 • pytest‑cov → aim ≥ 90 % on core and endpoints; workflows can be looser
 • GitHub Actions → lint, type‑check, test on 3.10 → 3.12

Project scaffolding extras
 • pyproject.toml with optional-dependencies = { pandas = ["pandas>=2.2"] }
so pure‑API users can stay lightweight.
 • docs/ site via mkdocs‑material – auto‑generate API + How‑to pages from Jupyter notebooks in /examples/.
 • Semantic Versioning:
 • PATCH – bug fix, no signature change
 • MINOR – new endpoint/workflow, backwards compatible
 • MAJOR – breaking change (e.g., rename Record.values)

Testing layout

tests/
├── unit/            # mock HTTP, focus on endpoints/utils
├── integration/     # hit sandbox credentials nightly
└── workflow/        # heavy DF comparisons, snapshot tests

Packaging tip

Expose just two symbols at top level:

# imednet/__init__.py

from .sdk import ImednetSDK, Context
__all__ = ["ImednetSDK", "Context"]

Everything else is internal, but power users can still import imednet.workflows.record_mapper as rm.

⸻

4 What to build next (ordered)
 1. Land the Context pattern and refactor existing endpoints.
 2. Flesh out VariableEndpoint & RecordEndpoint first—they unlock most workflows.
 3. Implement record_mapper + unit tests (it becomes your golden pattern).
 4. Add export_bundle (easy win; shows value quickly).
 5. Wire CI, linting, typing, docs scaffold.
 6. Iterate on other workflows as real study teams request them.

Stay disciplined about layer boundaries and you’ll keep the codebase small‑surface, big‑power.
Ping me whenever you’d like a deeper design or code review on any of these pieces!
